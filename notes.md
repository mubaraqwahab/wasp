# Notes

Compilation comprises three main stages: parsing, transformation, and generation. An intermediate representation of the source code is created through parsing, then transformations are applied to the representation before a string of code in a target language is generated.

- [Lexing](#lexing)
- [Parsing](#parsing)

## Lexing

Parsing is of two phases; the first is lexical analysis, or _lexing_. A lexical analyzer is also known as a _lexer_. A lexer reads the source code and turns it into a stream of _tokens_. Tokens are categories of _lexemes_ (that is, words or units) in a language. For example, consider the JavaScript expression `alert('Hi');`. The lexemes in it are `alert`, `(`, `'Hi'`, `)` and `;`. `alert` might correspond to the identifier token, `(` the open parenthesis token, `'Hi'` the string literal token, and so on.

The following is a basic, informal procedure for lexing:

1. Iterate over the source code character by character.
2. Identify the token associated with each lexeme.
3. Add the identified tokens to an array of tokens.

There are some important ways the procedure above could be modified. It is often useful to store some token metadata such as the token's location in the source code, etc. It might also not be wise to store all tokens in an array &ndash; consider how large the array would grow when parsing a large file. A third thing is that whitespace tokens (spaces, tabs and newlines) need not be stored, they should only be identified. Finally, characters that do not fit into any token category should be treated as (lexical) syntax errors.

## Parsing

The second phase of parsing is syntactic analysis (or syntax analysis). It may simply be called _parsing_. This phase imposes an hierarchical structure on the tokens generated by the lexer. The structure, known as an abstract syntax tree (AST), serves as an intermediate representation of the source code, and it helps in validating the syntax of the code, among other things.

> [AST Explorer](https://astexplorer.net/) is one tool for inspecting ASTs.

Here's a simple procedure for building an AST:

1. Iterate over the array of tokens.
2. Add each number, string, etc. to the current level of the tree.
3. Collect the arguments of each _call expression_ (e.g. a function) and then recurse down into the expression body.